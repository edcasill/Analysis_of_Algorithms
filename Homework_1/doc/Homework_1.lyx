#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass IEEEtran
\begin_preamble
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsfonts}\usepackage{algorithmic}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\end_preamble
\options conference
\use_default_options false
\maintain_unincluded_children no
\language english
\language_package none
\inputencoding auto-legacy
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
Homework 1 - Introduction to Algorithms
\end_layout

\begin_layout Author
\begin_inset Flex Author Name
status collapsed

\begin_layout Plain Layout
Edwing Alexis Casillas Valencia
\end_layout

\end_inset


\end_layout

\begin_layout After Title Text
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
In this homework,
 we review the Selection algorithm and the complexity calculation
\end_layout

\begin_layout Section*
Problem 1
\end_layout

\begin_layout Standard
Build a program in C that gets an integer in the shell and reverse the integer.
 For example,
 if you get 1234 at the shell you should return 4321.
 Here,
 we ask you to do the following:
\end_layout

\begin_layout Enumerate
Get the integer number from the shell - and see if the number given is really a integer and it is positive.
\end_layout

\begin_layout Enumerate
Look at the integer as a binary
\end_layout

\begin_layout Enumerate
Reverse the bits
\end_layout

\begin_layout Enumerate
Return the reversed number
\end_layout

\begin_deeper
\begin_layout Enumerate
You can use the idea of masks and <<
\end_layout

\end_deeper
\begin_layout Enumerate
Explain why it works
\end_layout

\begin_layout Enumerate
Calculate its complexity by counting the steps
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection*
Answer:
\end_layout

\begin_layout Standard
First I request the user to type an integer number into the shell,
 it doesn't matter that the user enters a negative number at this point.
\end_layout

\begin_layout Standard
Once I get the number,
 I convert this number into it's binary representation,
 for this,
 I use a mask of 32 bits (value of an int on C language) with 1 at the first position,
 then I do a bit to bit AND with the number I got from the user.
 C automatically storage and interprets the numbers in binary,
 that's why bit to bit operations are easy to implement.
 The results at every right shift are storage on an array.
\end_layout

\begin_layout Standard
Due I storage the number in 32 bits,
 the first digit tells me if the number is positive or negative.
\end_layout

\begin_layout Itemize
1 for negative
\end_layout

\begin_layout Itemize
0 for positive
\end_layout

\begin_layout Standard
If the number is negative,
 I just need to apply the two's complement.
 The way I did it was to find the first 1 of the LSB part,
 and from there leave all the 0's;
 on the rest of the number I applied again the same bit to bit operation,
 but with a NAND,
 this permits me change the 0's to 1's and vice versa.
 Once it's done the process,
 I show the binary representation to the user.
\end_layout

\begin_layout Standard
To reverse the number,
 I need to get the last digit from the given number and storage in the result variable,
 then multiply it by 10 (for number with +2 digits),
 and add the following digit applying the same logic.
 
\end_layout

\begin_layout Standard
I use the following steps on the script:
\end_layout

\begin_layout Enumerate
Initialize the variable I'll use on 0.
\end_layout

\begin_layout Enumerate
Multiply it by 10.
 Due binary uses multiples of 2,
 we can separate the *10 multiplication into one *8 and one *2 and apply the addition on them using left shift (<<3 and <<1).
 This is because mathematically,
 a multiplication are series of additions.
\end_layout

\begin_layout Enumerate
Get the module of the number dividing by 10.
\end_layout

\begin_layout Enumerate
Do the addition of the module with the result number.
\end_layout

\begin_layout Enumerate
Get the floor of the given number dividing by 10.
\end_layout

\begin_layout Enumerate
Repeat steps 2-5 until the floor is 0.
\end_layout

\begin_layout Standard
This permits us reverse the number using binary operations.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
O(x+6+x+6+8+x+1+6+x+x+1+n+8)\label{eq}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
O(n+5x+36)\label{eq-1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Were n are the n-cycles and x-constant cycles.
 Due I'm using all the bits that storage an int on C (32),
 every x-cycle is going to be executed 32 times.
 Substituting,
 we get the following complexity
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
O(n+196)\label{eq-2}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename revertion.png

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Shell
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textbf{
\end_layout

\end_inset

Note:
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 I'm attaching the the C file on the homework assignment
\end_layout

\begin_layout Section*
Problem 2
\end_layout

\begin_layout Itemize
Algorithm steps:
\end_layout

\begin_deeper
\begin_layout Enumerate
Initialization:
 The array is conceptually divided into two parts:
 a sorted subarray (initially empty) and an unsorted subarray (initially the entire array).
\end_layout

\begin_layout Enumerate
Iteration:
 For each pass through the unsorted subarray (from the first element to the second-to-last):
\end_layout

\begin_deeper
\begin_layout Enumerate
Find Minimum:
 Locate the smallest element within the current unsorted subarray.
\end_layout

\begin_layout Enumerate
Swap:
 Exchange this smallest element with the first element of the unsorted subarray.
\end_layout

\begin_layout Enumerate
Boundary Shift:
 The boundary between the sorted and unsorted subarrays shifts one position to the right,
 incorporating the newly sorted element.
\end_layout

\end_deeper
\begin_layout Enumerate
Termination:
 This process continues until the entire array is sorted.
\end_layout

\end_deeper
\begin_layout Enumerate
Use a single main.c file for this
\end_layout

\begin_layout Enumerate
compile this
\end_layout

\begin_layout Enumerate
Use the cont method to get me the complexity.
\end_layout

\begin_layout Subsection*
Answer:
\end_layout

\begin_layout Standard
First I initialize an array of n elements and I print it on the shell for the user.
 Once it is done,
 I calculate the length of the array dividing the bytes used to storage the array by the bytes of the first element.
\end_layout

\begin_layout Standard
Then I initialize a counter to travel around a 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 loop,
 at each loop,
 the minimum value is going to be updated by the value of the array that we're comparing.
 Inside that loop I initialize another loop,
 this one will compare the value of the i+1 position on the array with the minimum value of the array.
 If the i+1 value is less than the minimum value,
 it will be now the new minimum value.
\end_layout

\begin_layout Standard
Once I have the minimum value of the unsorted array,
 I storage the first value of it on a temporal variable.
 Then,
 I replace the first value of the array with the minimum and on the next position I insert the value of the temporary variable.
 I repeat this process n times,
 were n is the length of the array.
\end_layout

\begin_layout Standard
Once the array is sorted,
 I print it on the shell for the user.
\end_layout

\begin_layout Standard
The complexity is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
O(7+1+n+n*n+7+1+n+3)\label{eq-3}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
O(n^{2}+2n+19)\label{eq-4}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement htbp
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename selection.png

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Selection algorithm
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textbf{
\end_layout

\end_inset

Note:
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 I'm attaching the the C file on the homework assignment
\end_layout

\end_body
\end_document
